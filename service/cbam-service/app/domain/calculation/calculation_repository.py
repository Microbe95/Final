# ============================================================================
# üì¶ Calculation Repository - Product Îç∞Ïù¥ÌÑ∞ Ï†ëÍ∑º
# ============================================================================

import logging
from typing import List, Dict, Any, Optional
from datetime import datetime
import psycopg2
from psycopg2.extras import RealDictCursor
import os

logger = logging.getLogger(__name__)

class CalculationRepository:
    """Product Îç∞Ïù¥ÌÑ∞ Ï†ëÍ∑º ÌÅ¥ÎûòÏä§"""
    
    def __init__(self):
        self.database_url = os.getenv('DATABASE_URL')
        if not self.database_url:
            raise Exception("DATABASE_URL ÌôòÍ≤ΩÎ≥ÄÏàòÍ∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
        
        self._initialize_database()
    
    def _initialize_database(self):
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî"""
        try:
            import psycopg2
            from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
            
            # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
            conn = psycopg2.connect(self.database_url)
            conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
            conn.close()
            
            logger.info("‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏÑ±Í≥µ")
            self._create_tables()
            
        except Exception as e:
            logger.error(f"‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïã§Ìå®: {str(e)}")
            raise
    
    def _create_tables(self):
        """ÌïÑÏöîÌïú ÌÖåÏù¥Î∏îÎì§ÏùÑ ÏÉùÏÑ±Ìï©ÎãàÎã§"""
        try:
            import psycopg2
            from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
            
            conn = psycopg2.connect(self.database_url)
            conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
            
            with conn.cursor() as cursor:
                # product ÌÖåÏù¥Î∏îÏù¥ Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏
                cursor.execute("""
                    SELECT EXISTS (
                        SELECT FROM information_schema.tables 
                        WHERE table_name = 'product'
                    );
                """)
                
                if not cursor.fetchone()[0]:
                    logger.info("‚ö†Ô∏è product ÌÖåÏù¥Î∏îÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§. ÏàòÎèôÏúºÎ°ú ÏÉùÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî.")
                
                conn.commit()
                logger.info("‚úÖ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖåÏù¥Î∏î ÌôïÏù∏ ÏôÑÎ£å")
                
        except Exception as e:
            logger.error(f"‚ùå ÌÖåÏù¥Î∏î ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")
            raise
    
    # ============================================================================
    # üì¶ Product Í¥ÄÎ†® Î©îÏÑúÎìú
    # ============================================================================
    
    async def create_product(self, product_data: Dict[str, Any]) -> Dict[str, Any]:
        """Ï†úÌíà ÏÉùÏÑ±"""
        try:
            return await self._create_product_db(product_data)
        except Exception as e:
            logger.error(f"‚ùå Ï†úÌíà ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")
            raise
    
    async def get_products(self) -> List[Dict[str, Any]]:
        """Ï†úÌíà Î™©Î°ù Ï°∞Ìöå"""
        try:
            return await self._get_products_db()
        except Exception as e:
            logger.error(f"‚ùå Ï†úÌíà Î™©Î°ù Ï°∞Ìöå Ïã§Ìå®: {str(e)}")
            raise
    
    async def get_product(self, product_id: int) -> Optional[Dict[str, Any]]:
        """ÌäπÏ†ï Ï†úÌíà Ï°∞Ìöå"""
        try:
            return await self._get_product_db(product_id)
        except Exception as e:
            logger.error(f"‚ùå Ï†úÌíà Ï°∞Ìöå Ïã§Ìå®: {str(e)}")
            raise
    
    async def update_product(self, product_id: int, update_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Ï†úÌíà ÏàòÏ†ï"""
        try:
            return await self._update_product_db(product_id, update_data)
        except Exception as e:
            logger.error(f"‚ùå Ï†úÌíà ÏàòÏ†ï Ïã§Ìå®: {str(e)}")
            raise
    
    async def delete_product(self, product_id: int) -> bool:
        """Ï†úÌíà ÏÇ≠Ï†ú"""
        try:
            return await self._delete_product_db(product_id)
        except Exception as e:
            logger.error(f"‚ùå Ï†úÌíà ÏÇ≠Ï†ú Ïã§Ìå®: {str(e)}")
            raise

    # ============================================================================
    # üîÑ Process Í¥ÄÎ†® Î©îÏÑúÎìú
    # ============================================================================
    
    async def create_process(self, process_data: Dict[str, Any]) -> Dict[str, Any]:
        """ÌîÑÎ°úÏÑ∏Ïä§ ÏÉùÏÑ±"""
        try:
            return await self._create_process_db(process_data)
        except Exception as e:
            logger.error(f"‚ùå ÌîÑÎ°úÏÑ∏Ïä§ ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")
            raise
    
    async def get_processes(self) -> List[Dict[str, Any]]:
        """ÌîÑÎ°úÏÑ∏Ïä§ Î™©Î°ù Ï°∞Ìöå"""
        try:
            return await self._get_processes_db()
        except Exception as e:
            logger.error(f"‚ùå ÌîÑÎ°úÏÑ∏Ïä§ Î™©Î°ù Ï°∞Ìöå Ïã§Ìå®: {str(e)}")
            raise
    
    async def get_process(self, process_id: int) -> Optional[Dict[str, Any]]:
        """ÌäπÏ†ï ÌîÑÎ°úÏÑ∏Ïä§ Ï°∞Ìöå"""
        try:
            return await self._get_process_db(process_id)
        except Exception as e:
            logger.error(f"‚ùå ÌîÑÎ°úÏÑ∏Ïä§ Ï°∞Ìöå Ïã§Ìå®: {str(e)}")
            raise
    
    async def update_process(self, process_id: int, update_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """ÌîÑÎ°úÏÑ∏Ïä§ ÏàòÏ†ï"""
        try:
            return await self._update_process_db(process_id, update_data)
        except Exception as e:
            logger.error(f"‚ùå ÌîÑÎ°úÏÑ∏Ïä§ ÏàòÏ†ï Ïã§Ìå®: {str(e)}")
            raise
    
    async def delete_process(self, process_id: int) -> bool:
        """ÌîÑÎ°úÏÑ∏Ïä§ ÏÇ≠Ï†ú"""
        try:
            return await self._delete_process_db(process_id)
        except Exception as e:
            logger.error(f"‚ùå ÌîÑÎ°úÏÑ∏Ïä§ ÏÇ≠Ï†ú Ïã§Ìå®: {str(e)}")
            raise
    
    # ============================================================================
    # üóÑÔ∏è Database Î©îÏÑúÎìúÎì§
    # ============================================================================
    
    async def _create_product_db(self, product_data: Dict[str, Any]) -> Dict[str, Any]:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†úÌíà ÏÉùÏÑ±"""
        import psycopg2
        from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
        
        conn = psycopg2.connect(self.database_url)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
        
        try:
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    INSERT INTO product (
                        install_id, product_name, product_category, 
                        prostart_period, proend_period, product_amount,
                        product_cncode, goods_name, aggrgoods_name,
                        product_sell, product_eusell
                    ) VALUES (
                        %(install_id)s, %(product_name)s, %(product_category)s,
                        %(prostart_period)s, %(proend_period)s, %(product_amount)s,
                        %(product_cncode)s, %(goods_name)s, %(aggrgoods_name)s,
                        %(product_sell)s, %(product_eusell)s
                    ) RETURNING *
                """, product_data)
                
                result = cursor.fetchone()
                conn.commit()
                
                if result:
                    product_dict = dict(result)
                    # datetime.date Í∞ùÏ≤¥Î•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
                    if 'prostart_period' in product_dict and product_dict['prostart_period']:
                        product_dict['prostart_period'] = product_dict['prostart_period'].isoformat()
                    if 'proend_period' in product_dict and product_dict['proend_period']:
                        product_dict['proend_period'] = product_dict['proend_period'].isoformat()
                    return product_dict
                else:
                    raise Exception("Ï†úÌíà ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.")
                    
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()

    # ============================================================================
    # üîÑ Process Database Î©îÏÑúÎìúÎì§
    # ============================================================================
    
    async def _create_process_db(self, process_data: Dict[str, Any]) -> Dict[str, Any]:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê ÌîÑÎ°úÏÑ∏Ïä§ ÏÉùÏÑ±"""
        import psycopg2
        from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
        
        conn = psycopg2.connect(self.database_url)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
        
        try:
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    INSERT INTO process (
                        product_id, process_name, start_period, end_period
                    ) VALUES (
                        %(product_id)s, %(process_name)s, %(start_period)s, %(end_period)s
                    ) RETURNING *
                """, process_data)
                
                result = cursor.fetchone()
                conn.commit()
                
                if result:
                    process_dict = dict(result)
                    # datetime.date Í∞ùÏ≤¥Î•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
                    if 'start_period' in process_dict and process_dict['start_period']:
                        process_dict['start_period'] = process_dict['start_period'].isoformat()
                    if 'end_period' in process_dict and process_dict['end_period']:
                        process_dict['end_period'] = process_dict['end_period'].isoformat()
                    return process_dict
                else:
                    raise Exception("ÌîÑÎ°úÏÑ∏Ïä§ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.")
                    
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()
    
    async def _get_processes_db(self) -> List[Dict[str, Any]]:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÌîÑÎ°úÏÑ∏Ïä§ Î™©Î°ù Ï°∞Ìöå"""
        import psycopg2
        from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
        
        conn = psycopg2.connect(self.database_url)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
        
        try:
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT * FROM process ORDER BY id
                """)
                
                results = cursor.fetchall()
                processes = []
                for row in results:
                    process_dict = dict(row)
                    # datetime.date Í∞ùÏ≤¥Î•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
                    if 'start_period' in process_dict and process_dict['start_period']:
                        process_dict['start_period'] = process_dict['start_period'].isoformat()
                    if 'end_period' in process_dict and process_dict['end_period']:
                        process_dict['end_period'] = process_dict['end_period'].isoformat()
                    processes.append(process_dict)
                
                return processes
                
        except Exception as e:
            raise e
        finally:
            conn.close()
    
    async def _get_process_db(self, process_id: int) -> Optional[Dict[str, Any]]:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÌäπÏ†ï ÌîÑÎ°úÏÑ∏Ïä§ Ï°∞Ìöå"""
        import psycopg2
        from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
        
        conn = psycopg2.connect(self.database_url)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
        
        try:
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT * FROM process WHERE id = %s
                """, (process_id,))
                
                result = cursor.fetchone()
                if result:
                    process_dict = dict(result)
                    # datetime.date Í∞ùÏ≤¥Î•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
                    if 'start_period' in process_dict and process_dict['start_period']:
                        process_dict['start_period'] = process_dict['start_period'].isoformat()
                    if 'end_period' in process_dict and process_dict['end_period']:
                        process_dict['end_period'] = process_dict['end_period'].isoformat()
                    return process_dict
                return None
                
        except Exception as e:
            raise e
        finally:
            conn.close()
    
    async def _update_process_db(self, process_id: int, update_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÌîÑÎ°úÏÑ∏Ïä§ ÏàòÏ†ï"""
        import psycopg2
        from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
        
        conn = psycopg2.connect(self.database_url)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
        
        try:
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                # ÎèôÏ†ÅÏúºÎ°ú SET Ï†à ÏÉùÏÑ±
                set_clause = ", ".join([f"{key} = %s" for key in update_data.keys()])
                values = list(update_data.values()) + [process_id]
                
                cursor.execute(f"""
                    UPDATE process SET {set_clause} 
                    WHERE id = %s RETURNING *
                """, values)
                
                result = cursor.fetchone()
                conn.commit()
                
                if result:
                    process_dict = dict(result)
                    # datetime.date Í∞ùÏ≤¥Î•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
                    if 'start_period' in process_dict and process_dict['start_period']:
                        process_dict['start_period'] = process_dict['start_period'].isoformat()
                    if 'end_period' in process_dict and process_dict['end_period']:
                        process_dict['end_period'] = process_dict['end_period'].isoformat()
                    return process_dict
                return None
                
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()
    
    async def _delete_process_db(self, process_id: int) -> bool:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÌîÑÎ°úÏÑ∏Ïä§ ÏÇ≠Ï†ú"""
        import psycopg2
        from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
        
        conn = psycopg2.connect(self.database_url)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
        
        try:
            with conn.cursor() as cursor:
                cursor.execute("""
                    DELETE FROM process WHERE id = %s
                """, (process_id,))
                
                conn.commit()
                return cursor.rowcount > 0
                
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()
    
    async def _get_products_db(self) -> List[Dict[str, Any]]:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú Ï†úÌíà Î™©Î°ù Ï°∞Ìöå"""
        import psycopg2
        from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
        
        conn = psycopg2.connect(self.database_url)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
        
        try:
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT * FROM product ORDER BY id
                """)
                
                results = cursor.fetchall()
                products = []
                for row in results:
                    product_dict = dict(row)
                    # datetime.date Í∞ùÏ≤¥Î•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
                    if 'prostart_period' in product_dict and product_dict['prostart_period']:
                        product_dict['prostart_period'] = product_dict['prostart_period'].isoformat()
                    if 'proend_period' in product_dict and product_dict['proend_period']:
                        product_dict['proend_period'] = product_dict['proend_period'].isoformat()
                    products.append(product_dict)
                
                return products
                
        except Exception as e:
            raise e
        finally:
            conn.close()
    
    async def _get_product_db(self, product_id: int) -> Optional[Dict[str, Any]]:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÌäπÏ†ï Ï†úÌíà Ï°∞Ìöå"""
        import psycopg2
        from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
        
        conn = psycopg2.connect(self.database_url)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
        
        try:
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT * FROM product WHERE id = %s
                """, (product_id,))
                
                result = cursor.fetchone()
                if result:
                    product_dict = dict(result)
                    # datetime.date Í∞ùÏ≤¥Î•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
                    if 'prostart_period' in product_dict and product_dict['prostart_period']:
                        product_dict['prostart_period'] = product_dict['prostart_period'].isoformat()
                    if 'proend_period' in product_dict and product_dict['proend_period']:
                        product_dict['proend_period'] = product_dict['proend_period'].isoformat()
                    return product_dict
                return None
                
        except Exception as e:
            raise e
        finally:
            conn.close()
    
    async def _update_product_db(self, product_id: int, update_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú Ï†úÌíà ÏàòÏ†ï"""
        import psycopg2
        from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
        
        conn = psycopg2.connect(self.database_url)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
        
        try:
            with conn.cursor(cursor_factory=RealDictCursor) as cursor:
                # ÎèôÏ†ÅÏúºÎ°ú SET Ï†à ÏÉùÏÑ±
                set_clause = ", ".join([f"{key} = %s" for key in update_data.keys()])
                values = list(update_data.values()) + [product_id]
                
                cursor.execute(f"""
                    UPDATE product SET {set_clause} 
                    WHERE id = %s RETURNING *
                """, values)
                
                result = cursor.fetchone()
                conn.commit()
                
                if result:
                    product_dict = dict(result)
                    # datetime.date Í∞ùÏ≤¥Î•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
                    if 'prostart_period' in product_dict and product_dict['prostart_period']:
                        product_dict['prostart_period'] = product_dict['prostart_period'].isoformat()
                    if 'proend_period' in product_dict and product_dict['proend_period']:
                        product_dict['proend_period'] = product_dict['proend_period'].isoformat()
                    return product_dict
                return None
                
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()
    
    async def _delete_product_db(self, product_id: int) -> bool:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú Ï†úÌíà ÏÇ≠Ï†ú"""
        import psycopg2
        from psycopg2.extensions import ISOLATION_LEVEL_AUTOCOMMIT
        
        conn = psycopg2.connect(self.database_url)
        conn.set_isolation_level(ISOLATION_LEVEL_AUTOCOMMIT)
        
        try:
            with conn.cursor() as cursor:
                cursor.execute("""
                    DELETE FROM product WHERE id = %s
                """, (product_id,))
                
                conn.commit()
                return cursor.rowcount > 0
                
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()