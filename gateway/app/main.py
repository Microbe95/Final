"""
Gateway API Î©îÏù∏ ÌååÏùº (Îã®Ïùº ÌååÏùº ÌÜµÌï© Î≤ÑÏ†Ñ)
- CORS ÏÑ§Ï†ï
- Ìó¨Ïä§ Ï≤¥ÌÅ¨
- Î≤îÏö© ÌîÑÎ°ùÏãú(/api/v1/{service}/{path})
- ÏÑúÎπÑÏä§ ÎîîÏä§Ïª§Î≤ÑÎ¶¨ Í∏∞Îä•(ÌôòÍ≤ΩÎ≥ÄÏàò Í∏∞Î∞ò)
"""

from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, Response
import os
import logging
import sys
from dotenv import load_dotenv
from contextlib import asynccontextmanager
import httpx

# ÌôòÍ≤Ω Î≥ÄÏàò Î°úÎìú (.envÎäî Î°úÏª¨ÏóêÏÑúÎßå ÏÇ¨Ïö©)
if not os.getenv("RAILWAY_ENVIRONMENT"):
    load_dotenv()

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)],
)
logger = logging.getLogger("gateway_api")

# ÏÑúÎπÑÏä§ Îßµ Íµ¨ÏÑ± (MSA ÏõêÏπô: Í∞Å ÏÑúÎπÑÏä§Îäî ÎèÖÎ¶ΩÏ†ÅÏù∏ URLÏùÑ Í∞ÄÏ†∏Ïïº Ìï®)
# üî¥ ÏàòÏ†ï: ÌòÑÏû¨ ÌôòÍ≤ΩÎ≥ÄÏàò ÏÑ§Ï†ïÏóê ÎßûÍ≤å ÏàòÏ†ï
AUTH_SERVICE_URL = os.getenv("AUTH_SERVICE_URL", "https://auth-service-production-d3.up.railway.app")
CAL_BOUNDARY_URL = os.getenv("CAL_BOUNDARY_URL", "https://lcafinal-production.up.railway.app")

# Railway Î∞∞Ìè¨ ÌòÑÌô©: CBAM ÏÑúÎπÑÏä§Í∞Ä ÌÜµÌï©ÎêòÏñ¥ ÏûàÏùå
# Î™®Îì† CBAM Í¥ÄÎ†® ÎèÑÎ©îÏù∏ÏùÄ ÌïòÎÇòÏùò ÏÑúÎπÑÏä§ÏóêÏÑú Ï≤òÎ¶¨

# ÌôòÍ≤ΩÎ≥ÄÏàò ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏
logger.info(f"üîß ÌôòÍ≤ΩÎ≥ÄÏàò ÌôïÏù∏:")
logger.info(f"   CAL_BOUNDARY_URL: {CAL_BOUNDARY_URL}")
logger.info(f"   AUTH_SERVICE_URL: {AUTH_SERVICE_URL}")
logger.info(f"   RAILWAY_ENVIRONMENT: {os.getenv('RAILWAY_ENVIRONMENT', 'Not Set')}")
logger.info(f"   CORS_URL: {os.getenv('CORS_URL', 'Not Set')}")
logger.info(f"   CORS_ALLOW_CREDENTIALS: {os.getenv('CORS_ALLOW_CREDENTIALS', 'Not Set')}")

# üî¥ Ï∂îÍ∞Ä: AUTH_SERVICE_URL Í≤ÄÏ¶ù
if AUTH_SERVICE_URL and AUTH_SERVICE_URL.startswith("http://") and ":" in AUTH_SERVICE_URL.split("//")[1]:
    logger.warning(f"‚ö†Ô∏è AUTH_SERVICE_URLÏù¥ Docker ÎÇ¥Î∂Ä Ï£ºÏÜåÏùº Ïàò ÏûàÏäµÎãàÎã§: {AUTH_SERVICE_URL}")
    logger.warning(f"   Railway Î∞∞Ìè¨ÏóêÏÑúÎäî Ïô∏Î∂Ä HTTPS URLÏùÑ ÏÇ¨Ïö©ÌïòÎäî Í≤ÉÏù¥ Ï¢ãÏäµÎãàÎã§")

SERVICE_MAP = {
    "auth": AUTH_SERVICE_URL,
    # CBAM ÏÑúÎπÑÏä§ (ÌÜµÌï© ÏÑúÎπÑÏä§) - Î™®Îì† ÎèÑÎ©îÏù∏ÏùÑ Ï≤òÎ¶¨
    # ÌîÑÎ°†Ìä∏ÏóîÎìú Ìò∏ÌôòÏö© Î≥ÑÏπ≠
    "cal-boundary": CAL_BOUNDARY_URL,
    "cal_boundary": CAL_BOUNDARY_URL,
    # Íµ≠Í∞Ä/ÏßÄÏó≠ Í¥ÄÎ†® ÏÑúÎπÑÏä§ (boundary ÏÑúÎπÑÏä§ÏóêÏÑú Ï≤òÎ¶¨)
    "countries": CAL_BOUNDARY_URL,
    # Material Directory ÏÑúÎπÑÏä§ (CBAM ÏÑúÎπÑÏä§ÏóêÏÑú Ï≤òÎ¶¨)
    "matdir": CAL_BOUNDARY_URL,
    # Process Chain ÏÑúÎπÑÏä§ (CBAM ÏÑúÎπÑÏä§ÏóêÏÑú Ï≤òÎ¶¨)
    "processchain": CAL_BOUNDARY_URL,
    # Í∏∞ÌÉÄ CBAM Í¥ÄÎ†® ÏÑúÎπÑÏä§Îì§
    "product": CAL_BOUNDARY_URL,
    "process": CAL_BOUNDARY_URL,
    "edge": CAL_BOUNDARY_URL,
    "mapping": CAL_BOUNDARY_URL,
    "fueldir": CAL_BOUNDARY_URL,
    "productprocess": CAL_BOUNDARY_URL,
    "calculation": CAL_BOUNDARY_URL,
    # üî¥ ÏßÅÏ†ë ÏÑúÎπÑÏä§ ÎùºÏö∞ÌåÖ (prefix Ï§ëÎ≥µ Î∞©ÏßÄ)
    "install": CAL_BOUNDARY_URL,
}

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("üöÄ Gateway API ÏãúÏûë (Îã®Ïùº ÌååÏùº ÌÜµÌï©)")
    
    # üî¥ Ï∂îÍ∞Ä: ÌôòÍ≤ΩÎ≥ÄÏàò Í≤ÄÏ¶ù
    logger.info("üîç ÌôòÍ≤ΩÎ≥ÄÏàò Í≤ÄÏ¶ù:")
    
    # ÌïÑÏàò ÌôòÍ≤ΩÎ≥ÄÏàò ÌôïÏù∏
    required_envs = {
        "AUTH_SERVICE_URL": AUTH_SERVICE_URL,
        "CAL_BOUNDARY_URL": CAL_BOUNDARY_URL,
    }
    
    for env_name, env_value in required_envs.items():
        if env_value and env_value.startswith("https://"):
            logger.info(f"   ‚úÖ {env_name}: {env_value}")
        elif env_value and env_value.startswith("http://"):
            logger.warning(f"   ‚ö†Ô∏è {env_name}: {env_value} (HTTP ÏÇ¨Ïö© - ÌîÑÎ°úÎçïÏÖòÏóêÏÑúÎäî HTTPS Í∂åÏû•)")
        else:
            logger.warning(f"   ‚ö†Ô∏è {env_name}: {env_value} (Ïò¨Î∞îÎ•∏ URLÏù¥ ÏïÑÎãôÎãàÎã§)")
    
    # üî¥ Ï∂îÍ∞Ä: AUTH_SERVICE_URLÏù¥ Docker ÎÇ¥Î∂Ä Ï£ºÏÜåÏù∏ÏßÄ ÌôïÏù∏
    if AUTH_SERVICE_URL and AUTH_SERVICE_URL.startswith("http://") and ":" in AUTH_SERVICE_URL.split("//")[1]:
        logger.warning(f"   ‚ö†Ô∏è AUTH_SERVICE_URLÏù¥ Docker ÎÇ¥Î∂Ä Ï£ºÏÜåÏùº Ïàò ÏûàÏäµÎãàÎã§: {AUTH_SERVICE_URL}")
        logger.warning(f"   Railway Î∞∞Ìè¨ÏóêÏÑúÎäî Ïô∏Î∂Ä HTTPS URLÏùÑ ÏÇ¨Ïö©ÌïòÎäî Í≤ÉÏù¥ Ï¢ãÏäµÎãàÎã§")
    
    # CORS ÏÑ§Ï†ï ÌôïÏù∏
    if not allowed_origins:
        logger.warning("   ‚ö†Ô∏è CORS ÌóàÏö© Ïò§Î¶¨ÏßÑÏù¥ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§")
    else:
        logger.info(f"   ‚úÖ CORS ÌóàÏö© Ïò§Î¶¨ÏßÑ: {len(allowed_origins)}Í∞ú")
        # Gateway URLÏù¥ CORSÏóê Ìè¨Ìï®ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        gateway_url = "https://gateway-production-22ef.up.railway.app"
        if gateway_url in allowed_origins:
            logger.info(f"   ‚úÖ Gateway URLÏù¥ CORSÏóê Ìè¨Ìï®Îê®: {gateway_url}")
        else:
            logger.warning(f"   ‚ö†Ô∏è Gateway URLÏù¥ CORSÏóê Ìè¨Ìï®ÎêòÏßÄ ÏïäÏùå: {gateway_url}")
            logger.warning(f"   Gateway ÏûêÏ≤¥Ïóê ÎåÄÌïú ÏöîÏ≤≠Ïù¥ Ï∞®Îã®Îê† Ïàò ÏûàÏäµÎãàÎã§")
    
    logger.info("üîó Îì±Î°ùÎêú ÏÑúÎπÑÏä§ Î™©Î°ù:")
    for service_name, service_url in SERVICE_MAP.items():
        logger.info(f"   {service_name}: {service_url}")
    
    yield
    logger.info("üõë Gateway API Ï¢ÖÎ£å")

app = FastAPI(
    title="Gateway API",
    description="Gateway API for LCA Final - Railway Î∞∞Ìè¨ Î≤ÑÏ†Ñ (MSA ÏïÑÌÇ§ÌÖçÏ≤ò)",
    version="1.0.0",
    docs_url="/docs",
    lifespan=lifespan,
)

# CORS ÏÑ§Ï†ï - ÌîÑÎ°†Ìä∏ÏóîÎìú Ïò§Î¶¨ÏßÑÎßå ÌóàÏö© (Í≤åÏù¥Ìä∏Ïõ®Ïù¥ ÏûêÍ∏∞ ÏûêÏã†ÏùÄ Ï†úÏô∏)
allowed_origins = [o.strip() for o in os.getenv("CORS_URL", "").split(",") if o.strip()]
if not allowed_origins:
    allowed_origins = [
        "https://lca-final.vercel.app",  # Vercel ÌîÑÎ°úÎçïÏÖò ÌîÑÎ°†Ìä∏ÏóîÎìú
        "https://greensteel.site",       # Ïª§Ïä§ÌÖÄ ÎèÑÎ©îÏù∏ (ÏûàÎã§Î©¥)
        "http://localhost:3000",         # Î°úÏª¨ Í∞úÎ∞ú ÌôòÍ≤Ω
    ]

# üî¥ ÏàòÏ†ï: CORS ÏÑ§Ï†ïÏùÑ Îçî Ïú†Ïó∞ÌïòÍ≤å
allow_credentials = os.getenv("CORS_ALLOW_CREDENTIALS", "true").lower() == "true"
allow_methods = [m.strip() for m in os.getenv("CORS_ALLOW_METHODS", "GET,POST,PUT,DELETE,OPTIONS,PATCH").split(",")]
allow_headers = [h.strip() for h in os.getenv("CORS_ALLOW_HEADERS", "*").split(",")]

# CORS ÏÑ§Ï†ï Ï†Ñ Î°úÍπÖ
logger.info(f"üîß CORS ÏÑ§Ï†ï Ï§ÄÎπÑ:")
logger.info(f"   ÌôòÍ≤ΩÎ≥ÄÏàò CORS_URL: {os.getenv('CORS_URL', 'Not Set')}")
logger.info(f"   ÏµúÏ¢Ö ÌóàÏö©Îêú Ïò§Î¶¨ÏßÑ: {allowed_origins}")
logger.info(f"   ÏûêÍ≤©Ï¶ùÎ™Ö ÌóàÏö©: {allow_credentials}")
logger.info(f"   ÌóàÏö©Îêú Î©îÏÑúÎìú: {allow_methods}")
logger.info(f"   ÌóàÏö©Îêú Ìó§Îçî: {allow_headers}")

# üî¥ Ï∂îÍ∞Ä: Gateway URLÏù¥ CORSÏóê Ìè¨Ìï®ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
gateway_url = "https://gateway-production-22ef.up.railway.app"
if gateway_url in allowed_origins:
    logger.info(f"   ‚úÖ Gateway URLÏù¥ CORSÏóê Ìè¨Ìï®Îê®: {gateway_url}")
else:
    logger.warning(f"   ‚ö†Ô∏è Gateway URLÏù¥ CORSÏóê Ìè¨Ìï®ÎêòÏßÄ ÏïäÏùå: {gateway_url}")
    logger.warning(f"   Gateway ÏûêÏ≤¥Ïóê ÎåÄÌïú ÏöîÏ≤≠Ïù¥ Ï∞®Îã®Îê† Ïàò ÏûàÏäµÎãàÎã§")
    logger.warning(f"   CORS_URLÏóê '{gateway_url}'ÏùÑ Ï∂îÍ∞ÄÌïòÎäî Í≤ÉÏùÑ Í∂åÏû•Ìï©ÎãàÎã§")

app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins,
    allow_credentials=allow_credentials,
    allow_methods=allow_methods,
    allow_headers=allow_headers,
)

logger.info(f"üîß CORS ÏÑ§Ï†ï ÏôÑÎ£å:")
logger.info(f"   ÌóàÏö©Îêú Ïò§Î¶¨ÏßÑ: {allowed_origins}")
logger.info(f"   ÏûêÍ≤©Ï¶ùÎ™Ö ÌóàÏö©: {allow_credentials}")
logger.info(f"   ÌóàÏö©Îêú Î©îÏÑúÎìú: {allow_methods}")
logger.info(f"   ÌóàÏö©Îêú Ìó§Îçî: {allow_headers}")

# ÌîÑÎ°ùÏãú Ïú†Ìã∏Î¶¨Ìã∞
async def proxy_request(service: str, path: str, request: Request) -> Response:
    base_url = SERVICE_MAP.get(service)
    if not base_url:
        logger.error(f"‚ùå Unknown service: {service}")
        return JSONResponse(status_code=404, content={"detail": f"Unknown service: {service}"})

    # üî¥ ÏàòÏ†ï: Îπà Í≤ΩÎ°ú Ï≤òÎ¶¨ Î°úÏßÅ Ï∂îÍ∞Ä
    # MSA ÏõêÏπô: Í∞Å ÏÑúÎπÑÏä§Îäî ÏûêÏ≤¥ Í≤ΩÎ°ú Íµ¨Ï°∞Î•º Í∞ÄÏ†∏Ïïº Ìï®
    # GatewayÎäî Îã®ÏàúÌûà ÏöîÏ≤≠ÏùÑ Ï†ÑÎã¨Îßå Ìï® (Í≤ΩÎ°ú Ï°∞Ïûë Í∏àÏßÄ)
    if not path or path == "":
        # üî¥ ÏàòÏ†ï: install ÏÑúÎπÑÏä§Ïùò Îπà Í≤ΩÎ°úÎ•º /installÏúºÎ°ú Îß§Ìïë
        if service == "install":
            normalized_path = "install"
            logger.info(f"üîç Install ÏÑúÎπÑÏä§ Îπà Í≤ΩÎ°ú Í∞êÏßÄ ‚Üí /installÏúºÎ°ú Îß§Ìïë")
        else:
            # Îπà Í≤ΩÎ°úÏùº ÎïåÎäî ÏÑúÎπÑÏä§Ïùò Î£®Ìä∏ Í≤ΩÎ°úÎ°ú Ï†ÑÎã¨
            normalized_path = ""
            logger.info(f"üîç Îπà Í≤ΩÎ°ú Í∞êÏßÄ: service={service}, path='{path}' ‚Üí Î£®Ìä∏ Í≤ΩÎ°úÎ°ú Ï†ÑÎã¨")
    else:
        normalized_path = path

    target_url = f"{base_url.rstrip('/')}/{normalized_path}".rstrip('/')
    
    # ÎùºÏö∞ÌåÖ Ï†ïÎ≥¥ Î°úÍπÖ
    logger.info(f"üîÑ ÌîÑÎ°ùÏãú ÎùºÏö∞ÌåÖ: {service} -> {target_url}")
    logger.info(f"   ÏõêÎ≥∏ Í≤ΩÎ°ú: {path}")
    logger.info(f"   Ï†ïÍ∑úÌôîÎêú Í≤ΩÎ°ú: {normalized_path}")
    logger.info(f"   ÏÑúÎπÑÏä§: {service}")
    logger.info(f"   Í∏∞Î≥∏ URL: {base_url}")
    logger.info(f"   ÏµúÏ¢Ö ÌÉÄÍ≤ü: {target_url}")
    
    method = request.method
    headers = dict(request.headers)
    headers.pop("host", None)
    params = dict(request.query_params)
    body = await request.body()

    timeout = httpx.Timeout(30.0, connect=10.0)
    
    # üî¥ ÏàòÏ†ï: resp Î≥ÄÏàòÎ•º Ìï®Ïàò ÏãúÏûë Ïãú Ï¥àÍ∏∞Ìôî
    resp = None
    
    async with httpx.AsyncClient(timeout=timeout) as client:
        try:
            resp = await client.request(
                method=method,
                url=target_url,
                headers=headers,
                params=params,
                content=body,
            )
            
            # ÏùëÎãµ ÏÉÅÌÉú ÏΩîÎìú Î°úÍπÖ
            logger.info(f"‚úÖ ÌîÑÎ°ùÏãú ÏùëÎãµ: {method} {target_url} -> {resp.status_code}")
            
        except httpx.RequestError as e:
            logger.error(f"‚ùå Upstream request error: {e}")
            return JSONResponse(
                status_code=502, 
                content={
                    "detail": "Bad Gateway", 
                    "error": str(e),
                    "service": service,
                    "target_url": target_url
                }
            )
        except httpx.TimeoutException as e:
            logger.error(f"‚ùå Upstream timeout: {e}")
            return JSONResponse(
                status_code=504, 
                content={
                    "detail": "Gateway Timeout", 
                    "error": str(e),
                    "service": service,
                    "target_url": target_url
                }
            )
        except Exception as e:
            logger.error(f"‚ùå Unexpected proxy error: {e}")
            return JSONResponse(
                status_code=500, 
                content={
                    "detail": "Internal Gateway Error", 
                    "error": str(e),
                    "service": service,
                    "target_url": target_url
                }
            )

    # üî¥ ÏàòÏ†ï: respÍ∞Ä NoneÏù¥ ÏïÑÎãåÏßÄ ÌôïÏù∏
    if resp is None:
        logger.error("‚ùå ÏùëÎãµ Í∞ùÏ≤¥Í∞Ä NoneÏûÖÎãàÎã§")
        return JSONResponse(
            status_code=500,
            content={
                "detail": "Internal Gateway Error",
                "error": "Response object is None",
                "service": service,
                "target_url": target_url
            }
        )

    # ÏùëÎãµ Ìó§Îçî Ï†ïÎ¶¨
    response_headers = {k: v for k, v in resp.headers.items() 
                       if k.lower() not in {"content-encoding", "transfer-encoding", "connection"}}
    
    return Response(
        content=resp.content, 
        status_code=resp.status_code, 
        headers=response_headers, 
        media_type=resp.headers.get("content-type")
    )

# Î≤îÏö© ÌîÑÎ°ùÏãú ÎùºÏö∞Ìä∏ (Î©îÏù∏ ÎùºÏö∞ÌåÖ Ïó≠Ìï†)
@app.api_route("/api/v1/{service}/{path:path}", methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"])
async def proxy(service: str, path: str, request: Request):
    # OPTIONS ÏöîÏ≤≠ÏùÄ CORS preflightÏù¥ÎØÄÎ°ú GatewayÏóêÏÑú ÏßÅÏ†ë Ï≤òÎ¶¨
    if request.method == "OPTIONS":
        # CORS Ìó§ÎçîÎ•º ÏùºÍ¥ÄÎêòÍ≤å ÏÑ§Ï†ï
        origin = request.headers.get("origin", "")
        logger.info(f"üîç CORS preflight ÏöîÏ≤≠ - origin: {origin}, ÌóàÏö©Îêú origins: {allowed_origins}")
        
        if origin in allowed_origins:
            return Response(
                status_code=200,
                headers={
                    "Access-Control-Allow-Origin": origin,
                    "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, PATCH, OPTIONS",
                    "Access-Control-Allow-Headers": "*",
                    "Access-Control-Max-Age": "86400",
                }
            )
        else:
            logger.warning(f"üö´ CORS origin Í±∞Î∂Ä: {origin}")
            return Response(
                status_code=400,
                content={"detail": "Origin not allowed", "requested_origin": origin, "allowed_origins": allowed_origins},
                headers={"Access-Control-Allow-Origin": allowed_origins[0] if allowed_origins else ""}
            )
    
    return await proxy_request(service, path, request)



# Ìó¨Ïä§ Ï≤¥ÌÅ¨
@app.get("/health", summary="Gateway Ìó¨Ïä§ Ï≤¥ÌÅ¨")
async def health_check_root():
    return {
        "status": "healthy", 
        "service": "gateway", 
        "version": "1.0.0",
        "environment": "railway-production",
        "services": {
            "auth": AUTH_SERVICE_URL,
            "cbam": CAL_BOUNDARY_URL,
            "database": "postgres-production-0d25.up.railway.app"
        }
    }

# ÏöîÏ≤≠ Î°úÍπÖ
@app.middleware("http")
async def log_all_requests(request: Request, call_next):
    logger.info(f"üåê {request.method} {request.url.path} origin={request.headers.get('origin','N/A')}")
    response = await call_next(request)
    logger.info(f"üåê ÏùëÎãµ: {response.status_code}")
    return response

# ÏòàÏô∏ Ï≤òÎ¶¨
@app.exception_handler(404)
async def not_found_handler(request: Request, exc):
    logger.error("üö® 404")
    return JSONResponse(status_code=404, content={"detail": f"Not Found: {request.url}", "path": request.url.path})

@app.exception_handler(405)
async def method_not_allowed_handler(request: Request, exc):
    logger.error("üö® 405")
    return JSONResponse(status_code=405, content={"detail": f"Method Not Allowed: {request.method} {request.url}"})

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", "8080"))
    logger.info(f"üöÄ Gateway API ÏãúÏûë - Ìè¨Ìä∏: {port}")
    uvicorn.run(app, host="0.0.0.0", port=port)
